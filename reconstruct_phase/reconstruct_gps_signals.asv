% ============== reconstruct_gps_signals.m ==============
%重建单点的GPS信号

function [recon_pseudorange, recon_phase] = reconstruct_gps_signals(method, current_epoch, sat_id, sat_states, receiver_pos, receiver_clk_err_sec)
% RECONSTRUCT_GPS_SIGNALS - 根据GPSense论文或标准方法重建伪距和相位。
%
% 语法: [recon_pseudorange, recon_phase] = reconstruct_gps_signals(method, ...)
%
% 输入:
%    method               - 字符串, 'standard' 或 'gpsense'
%    current_epoch        - 当前历元的观测数据 (来自 obs_data)
%    sat_id               - 要处理的卫星ID, 例如 'G10'
%    sat_states           - 由 a_calculate_receiver_position 解算出的所有卫星的状态
%    receiver_pos         - 解算出的接收机位置
%    receiver_clk_err_sec - 解算出的接收机钟差
%
% 输出:
%    recon_pseudorange - 重建后的伪距 (米)
%    recon_phase       - 重建后的相位 (根据方法不同，单位为米或弧度)

% --- 常数 ---
c = 299792458.0;         % 光速 (m/s)
f_L1 = 1575.42e6;        % L1 频率 (Hz)
lambda_L1 = c / f_L1;    % L1 波长 (m)

% --- 从输入中提取所需数据 ---
P_raw = current_epoch.data.(sat_id).pseudorange.C1C;
sat_state = sat_states.(sat_id);
sat_clk_err = sat_state.clock_error;

% --- 1. 重建伪距 (两种方法通用) ---
% ρ' = P_raw - c * (dt_r - dt_s)
recon_pseudorange = P_raw - c * (receiver_clk_err_sec - sat_clk_err);

% --- 2. 根据所选方法重建相位 ---
if strcmpi(method, 'standard')
    %% 方法A: 标准载波相位修正 (更稳定，推荐作为基准)
    L_raw_cycles = current_epoch.data.(sat_id).carrier_phase.L1C;
    if isnan(L_raw_cycles)
        recon_phase = NaN;
        warning('卫星 %s 缺少载波相位观测值，无法使用 standard 方法重建。', sat_id);
        return;
    end
    
    L_raw_meters = L_raw_cycles * lambda_L1;
    
    % L' = L + c*dt_r - c*dt_s (单位: 米)
    recon_phase = L_raw_meters + c * receiver_clk_err_sec - c * sat_clk_err;
    
elseif strcmpi(method, 'gpsense')
    %% 方法B: 复现 GPSense 论文方法
    % 获取测量多普勒 (RINEX Doppler是正值当距离缩短时)
    measured_doppler = current_epoch.data.(sat_id).doppler.D1C;
    if isnan(measured_doppler)
        recon_phase = NaN;
        warning('卫星 %s 缺少多普勒观测值，无法使用 gpsense 方法重建。', sat_id);
        return;
    end
    
    % 计算几何多普勒
    sat_pos = sat_state.position;
    sat_vel = sat_state.velocity;
    v_receiver = [0;0;0]; % 假设接收机静止
    v_rel = sat_vel - v_receiver;
    los_vec = (sat_pos - receiver_pos) / norm(sat_pos - receiver_pos);
    fD_geometric = -(v_rel' * los_vec) / lambda_L1;
    
    % 组合论文公式(5)的核心部分 (注意：已忽略原文中有疑问的 *t 项)
    doppler_residual_cycles = measured_doppler - fD_geometric;
    pseudorange_cycles = (P_raw - c * receiver_clk_err_sec) / lambda_L1;
    
    % 输出为弧度
    recon_phase = 2 * pi * (doppler_residual_cycles + pseudorange_cycles);
    
else
    error("未知的方法，请选择 'standard' 或 'gpsense'。");
end

end